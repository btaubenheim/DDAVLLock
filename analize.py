from spectrum import DFSpec
import time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['figure.subplot.hspace']=0.5
mpl.rcParams['backend']='TkAgg'
import Tkinter as tk
import tkFileDialog as tkf
import re

#a list with the properties of interest. entries are from the DFSpec methods
#or other supported functions
#supported functions have to take one DFSpec argument and return either a value or
#a list of the form [value, error]

global prop

prop=[DFSpec.lineDistance, DFSpec.symmetry199]

#prevent plt from blocking
plt.ion()

#------------------UTILITY FUNCTIONS---------------------------
def analization(dateien):
    #list with names of the fitted files
    files=[]
    
    #list with names of the evaluated properties
    propNames=[]
    for p in prop:
        propNames.append(p.__name__)    
    
    #list containing lists of every spectrums parameters
    params=[]
    #list containing lists of every spectrums parameters' errors
    paramErrs=[]
    #list with lists of every evaluated poperty's values
    propVals=[]
    #list containing errors of the evaluated properties
    propErrs=[]
    
    #list containing the Spectrum objects
    specs=[]
    
    for i in xrange(21):
        params.append([])
        paramErrs.append([])
    
    for i in prop:
        propVals.append([])
        propErrs.append([])
    
    #index for deciding when to begin a new plot
    j=0
        
    for datei in dateien:
        print datei
        if datei.endswith('.npy'):
            data=np.load(datei)
        elif datei.endswith('.csv') or datei.endswith('.txt'):
            try:
                data=np.loadtxt(datei)
            except:
                print 'could not open file '+datei
                continue
        else:
            print 'unknown format '+ datei
            continue
        files.append('...'+datei[-15:-4])
        s=DFSpec([data[3],data[1]])
        s.fitSpectrum()
        specs.append(s)
        for i in xrange(len(s.params)):
            params[i].append(s.params[i])
            paramErrs[i].append(s.errors[i])
            
        #now get the desired properties
        for i in xrange(len(prop)):
            #prop[i] is a function or class method taking s as an argument
            r=prop[i](s)
            #maybe prop[i] returns a tuple of value and error or only one value without error
            if type(r)==list or type(r) == tuple:
                propVals[i].append(r[0])
                propErrs[i].append(r[1])
            else:
                #there is no error for this value so set it to zero
                propVals[i].append(r)
                propErrs[i].append(0)
                
        #create a new figure for the spectra if the current is full
        if j%20 == 0:
            plt.figure(figsize=(20,20))
        axis=plt.subplot(5,4,j%20+1)
        s.plot(axis)
        plt.draw()
        j+=1
        
    #write the results to file
    saveLog(files, propNames, params, paramErrs, propVals, propErrs)

    return files, propNames, params, paramErrs, propVals, propErrs
    
def saveLog(files, propNames, params, paramErrs, propVals, propErrs, filename=None, listsep='\n', valsep=' '):
    ''' this function saves the data contained in the arguments. files and propnames must be lists of values,
    the other arguments lists of lists of values. listsep and valsep are the seperation characters for lists and values.
    if no filename is given, the date and time is taken.'''
    #header for the logfile.
    log='This is a logfile generated by analyze.py - lines containing the following: 1. filenames of the fitted spectra 2. names of the evaluated parameters 3. fitparameters of the spectra (one line for every parameter, in order of the filenames, this applies to the rest of the file) 4. errors of the fitparameters 5. evaluated properties 6. errors of the properties\n'
    #the lists are seperated by listsep, the values are seperated by valsep    
    for x in files, propNames:    
        log+=valsep.join([str(y) for y in x])
        log+=listsep
    
    for x in params, paramErrs, propVals, propErrs:
        for y in x:
            log+=valsep.join([str(z) for z in y])
            log+=listsep
    
    #remove the last listsep
    log=log[:-(len(listsep))]
    
    if not filename:
        filename='_'.join([str(x) for x in time.localtime()[:6]])+'.log'
    
    f=open(filename,'w')
    f.write(log)
    f.close()

def loadLog(filename, listsep='\n', valsep=' '):
    f=open(filename, 'r')
    header=f.readline()
    print header
    raw_data=f.read()
    lists=[x.split(valsep) for x in raw_data.split(listsep)]
    numlists=len(lists)
    files, propNames = lists[:2]
    numprops=len(propNames)
    numparams=(numlists-2*numprops-2)/2
    params=[[float(x) for x in l] for l in lists[2:numparams+2]]
    paramErrs=[[float(x) for x in l] for l in lists[numparams+2:2*numparams+2]]
    propVals=[[float(x) for x in l] for l in lists[-2*numprops:-numprops]]
    propErrs=[[float(x) for x in l] for l in lists[-numprops:]]
    
    return files, propNames, params, paramErrs, propVals, propErrs
    

#-----------------PROGRAM START------------------------

root=tk.Tk()
root.title("data analysis")
 
dateien=unicode(tkf.askopenfilenames())
 
dateien=re.findall('{.*?}',dateien)
root.destroy()
 
for i in xrange(len(dateien)):
    dateien[i]=dateien[i].replace('{','')
    dateien[i]=dateien[i].replace('}','')

if len(dateien) == 1 and dateien[0].endswith('.log'):
    files, propNames, params, paramErrs, propVals, propErrs = loadLog(dateien[0])
else:
    files, propNames, params, paramErrs, propVals, propErrs = analization(dateien)

numspecs=len(files)
numprop=len(propNames)

#create a figure for the parameters
plt.figure(figsize=(20,20))
#plot the properties
for i in xrange(len(params)):
    plt.subplot(5,5,i+1)
    plt.errorbar(range(numspecs),params[i],paramErrs[i])
    #set the function name as plot title
    plt.title('Parameter %d' % (i))

#create a figure for the evaluation of the given properties
plt.figure(figsize=(20,20))
#plot the properties
for i in xrange(numprop):
    plt.subplot(5,numprop/5+1,i+1)
    plt.errorbar(range(numspecs),propVals[i],propErrs[i])
    #set the function name as plot title
    plt.title(propNames[i])

plt.show()